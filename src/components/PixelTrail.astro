---
// Pixel Trail Component - Optimized for performance
// Removed expensive SVG filter, added idle detection, throttled to 30fps
---

<!-- Canvas for Pixel Trail -->
<canvas id="pixel-trail-canvas" class="pixel-trail-canvas"></canvas>

<style>
  .pixel-trail-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9999;
    will-change: transform;
  }
</style>

<script is:inline>
  (function() {
    function initPixelTrail() {
      // Check for reduced motion preferences
      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const isTouch = window.matchMedia('(hover: none)').matches;
      
      if (reducedMotion || isTouch) {
        return;
      }

      // Configuration - optimized for performance
      const config = {
        gridSize: 60, // Fewer pixels = better performance
        trailFadeTime: 200, // Shorter fade for less particles
        pixelColor: '#ffffff',
        minPixelSize: 10,
        maxPixelSize: 16,
        interpolationSteps: 3, // Reduced from 5 for better performance
        idleTimeout: 100, // Pause animation after 100ms of no movement
        targetFPS: 30 // Target 30fps instead of 60fps
      };

      // Initialize canvas
      const canvas = document.getElementById('pixel-trail-canvas');
      if (!canvas) {
        console.warn('Pixel Trail: Canvas not found');
        return;
      }
      
      const ctx = canvas.getContext('2d', { alpha: true });
      if (!ctx) {
        console.warn('Pixel Trail: Could not get canvas context');
        return;
      }

      console.log('âœ¨ Pixel Trail initialized');

      // Set canvas size
      let pixelSize;
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Calculate pixel size based on screen dimensions
        const minDim = Math.min(window.innerWidth, window.innerHeight);
        pixelSize = Math.max(config.minPixelSize, Math.min(config.maxPixelSize, minDim / config.gridSize));
      };

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Trail data structure - store grid cells that are active
      const trailMap = new Map();
      let mouseX = -100;
      let mouseY = -100;
      let lastMouseX = mouseX;
      let lastMouseY = mouseY;
      let lastMoveTime = Date.now();
      let isIdle = false;
      let animationId = null;

      // Mouse tracking with interpolation
      const handleMouseMove = (e) => {
        lastMouseX = mouseX;
        lastMouseY = mouseY;
        mouseX = e.clientX;
        mouseY = e.clientY;
        lastMoveTime = Date.now();

        // Resume animation if idle
        if (isIdle) {
          isIdle = false;
          render();
        }

        // Interpolate between last and current position for smooth trail
        const dx = mouseX - lastMouseX;
        const dy = mouseY - lastMouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, Math.ceil(distance / config.interpolationSteps));

        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = lastMouseX + dx * t;
          const y = lastMouseY + dy * t;

          // Convert to grid coordinates
          const gridX = Math.floor(x / pixelSize);
          const gridY = Math.floor(y / pixelSize);
          const key = `${gridX},${gridY}`;

          // Add to trail map with timestamp
          trailMap.set(key, Date.now());
        }
      };

      document.addEventListener('mousemove', handleMouseMove, { passive: true });

      // Render function with FPS throttling and idle detection
      let lastFrameTime = Date.now();
      const frameInterval = 1000 / config.targetFPS; // ~33ms for 30fps

      const render = () => {
        const now = Date.now();
        const timeSinceLastFrame = now - lastFrameTime;

        // Check if mouse has been idle
        if (now - lastMoveTime > config.idleTimeout && trailMap.size === 0) {
          isIdle = true;
          animationId = null;
          return; // Stop animation loop
        }

        // Throttle to target FPS
        if (timeSinceLastFrame < frameInterval) {
          animationId = requestAnimationFrame(render);
          return;
        }

        lastFrameTime = now - (timeSinceLastFrame % frameInterval);

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Render each active grid cell
        trailMap.forEach((timestamp, key) => {
          const age = now - timestamp;

          // Remove old trail points
          if (age > config.trailFadeTime) {
            trailMap.delete(key);
            return;
          }

          const [gridX, gridY] = key.split(',').map(Number);
          const x = gridX * pixelSize;
          const y = gridY * pixelSize;

          // Calculate opacity based on age (fade out)
          const opacity = 1 - (age / config.trailFadeTime);

          // Draw pixel
          ctx.globalAlpha = opacity;
          ctx.fillStyle = config.pixelColor;

          // Draw circle for smooth appearance
          ctx.beginPath();
          ctx.arc(x + pixelSize / 2, y + pixelSize / 2, pixelSize / 2, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.globalAlpha = 1;
        animationId = requestAnimationFrame(render);
      };

      // Start animation loop
      render();

      // Cleanup
      const cleanup = () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        document.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('resize', resizeCanvas);
        trailMap.clear();
      };

      window.addEventListener('beforeunload', cleanup);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPixelTrail);
    } else {
      initPixelTrail();
    }
  })();
</script>

