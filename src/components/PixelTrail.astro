---
// Pixel Trail Component - Optimized for performance
// Removed expensive SVG filter, added idle detection, throttled to 30fps
---

<!-- Canvas for Pixel Trail -->
<canvas id="pixel-trail-canvas" class="pixel-trail-canvas"></canvas>

<style>
  .pixel-trail-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 9999;
    will-change: transform;
  }
</style>

<script is:inline>
  (function() {
    function initPixelTrail() {
      // Check for reduced motion preferences
      const reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const isTouch = window.matchMedia('(hover: none)').matches;
      
      if (reducedMotion || isTouch) {
        return;
      }

      // Detect theme and set pixel color
      const isDark = document.documentElement.classList.contains('dark');
      const pixelColor = isDark ? '#a78bfa' : '#6e44ff'; // Purple for both modes

      // Configuration - optimized for performance
      const config = {
        gridSize: 60, // Fewer pixels = better performance
        trailFadeTime: 200, // Shorter fade for less particles
        pixelColor: pixelColor,
        minPixelSize: 10,
        maxPixelSize: 16,
        interpolationSteps: 3, // Reduced from 5 for better performance
        idleTimeout: 100, // Pause animation after 100ms of no movement
        targetFPS: 30 // Target 30fps instead of 60fps
      };

      // Initialize canvas
      const canvas = document.getElementById('pixel-trail-canvas');
      if (!canvas) {
        console.warn('Pixel Trail: Canvas not found');
        return;
      }
      
      const ctx = canvas.getContext('2d', { alpha: true });
      if (!ctx) {
        console.warn('Pixel Trail: Could not get canvas context');
        return;
      }

      console.log('âœ¨ Pixel Trail initialized');

      // Set canvas size
      let pixelSize;
      const resizeCanvas = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Calculate pixel size based on screen dimensions
        const minDim = Math.min(window.innerWidth, window.innerHeight);
        pixelSize = Math.max(config.minPixelSize, Math.min(config.maxPixelSize, minDim / config.gridSize));
      };

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      // Trail data structure - store grid cells that are active
      const trailMap = new Map();
      let mouseX = window.innerWidth / 2; // Start at center instead of off-screen
      let mouseY = window.innerHeight / 2;
      let lastMouseX = mouseX;
      let lastMouseY = mouseY;
      let lastMoveTime = Date.now();
      let isIdle = false;
      let animationId = null;
      let hasFirstMove = false; // Track if we've had first mouse movement

      // Update pixel color when theme changes
      const updatePixelColor = () => {
        const isDark = document.documentElement.classList.contains('dark');
        config.pixelColor = isDark ? '#a78bfa' : '#6e44ff'; // Purple for both modes
      };

      // Listen for theme changes
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'class') {
            updatePixelColor();
          }
        });
      });
      observer.observe(document.documentElement, { attributes: true });

      // Mouse tracking with interpolation
      const handleMouseMove = (e) => {
        // On first move, don't interpolate from center - just set position
        if (!hasFirstMove) {
          mouseX = e.clientX;
          mouseY = e.clientY;
          lastMouseX = mouseX;
          lastMouseY = mouseY;
          hasFirstMove = true;
          lastMoveTime = Date.now();

          // Resume animation if idle
          if (isIdle) {
            isIdle = false;
            render();
          }
          return;
        }

        lastMouseX = mouseX;
        lastMouseY = mouseY;
        mouseX = e.clientX;
        mouseY = e.clientY;
        lastMoveTime = Date.now();

        // Resume animation if idle
        if (isIdle) {
          isIdle = false;
          render();
        }

        // Interpolate between last and current position for smooth trail
        const dx = mouseX - lastMouseX;
        const dy = mouseY - lastMouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const steps = Math.max(1, Math.ceil(distance / config.interpolationSteps));

        for (let i = 0; i <= steps; i++) {
          const t = i / steps;
          const x = lastMouseX + dx * t;
          const y = lastMouseY + dy * t;

          // Convert to grid coordinates
          const gridX = Math.floor(x / pixelSize);
          const gridY = Math.floor(y / pixelSize);
          const key = `${gridX},${gridY}`;

          // Add to trail map with timestamp
          trailMap.set(key, Date.now());
        }
      };

      // Listen to mousemove on window to catch all mouse movements, including over iframes
      window.addEventListener('mousemove', handleMouseMove, { passive: true });

      // Handle iframe hover issue - when mouse enters iframe, we lose mousemove events
      // Create a transparent overlay that appears when we detect cursor is near/over an iframe
      let iframeOverlay = null;
      let iframeCheckInterval = null;

      const createIframeOverlay = () => {
        iframeOverlay = document.createElement('div');
        iframeOverlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          z-index: 9998;
          display: none;
        `;
        document.body.appendChild(iframeOverlay);
      };

      const checkIframeHover = () => {
        const iframes = document.querySelectorAll('iframe');
        let isOverIframe = false;

        iframes.forEach(iframe => {
          const rect = iframe.getBoundingClientRect();
          // Check if mouse is within iframe bounds
          if (mouseX >= rect.left && mouseX <= rect.right &&
              mouseY >= rect.top && mouseY <= rect.bottom) {
            isOverIframe = true;
          }
        });

        if (iframeOverlay) {
          iframeOverlay.style.display = isOverIframe ? 'block' : 'none';
        }
      };

      createIframeOverlay();
      // Check every 100ms if mouse might be over an iframe
      iframeCheckInterval = setInterval(checkIframeHover, 100);

      // Render function with FPS throttling and idle detection
      let lastFrameTime = Date.now();
      const frameInterval = 1000 / config.targetFPS; // ~33ms for 30fps

      const render = () => {
        const now = Date.now();
        const timeSinceLastFrame = now - lastFrameTime;

        // Check if mouse has been idle
        if (now - lastMoveTime > config.idleTimeout && trailMap.size === 0) {
          isIdle = true;
          animationId = null;
          return; // Stop animation loop
        }

        // Throttle to target FPS
        if (timeSinceLastFrame < frameInterval) {
          animationId = requestAnimationFrame(render);
          return;
        }

        lastFrameTime = now - (timeSinceLastFrame % frameInterval);

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Render each active grid cell
        trailMap.forEach((timestamp, key) => {
          const age = now - timestamp;

          // Remove old trail points
          if (age > config.trailFadeTime) {
            trailMap.delete(key);
            return;
          }

          const [gridX, gridY] = key.split(',').map(Number);
          const x = gridX * pixelSize;
          const y = gridY * pixelSize;

          // Calculate opacity based on age (fade out)
          const opacity = 1 - (age / config.trailFadeTime);

          // Draw pixel
          ctx.globalAlpha = opacity;
          ctx.fillStyle = config.pixelColor;

          // Draw circle for smooth appearance
          ctx.beginPath();
          ctx.arc(x + pixelSize / 2, y + pixelSize / 2, pixelSize / 2, 0, Math.PI * 2);
          ctx.fill();
        });

        ctx.globalAlpha = 1;
        animationId = requestAnimationFrame(render);
      };

      // Start animation loop
      render();

      // Cleanup
      const cleanup = () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        if (iframeCheckInterval) {
          clearInterval(iframeCheckInterval);
        }
        if (iframeOverlay) {
          iframeOverlay.remove();
        }
        window.removeEventListener('mousemove', handleMouseMove);
        window.removeEventListener('resize', resizeCanvas);
        observer.disconnect();
        trailMap.clear();
      };

      window.addEventListener('beforeunload', cleanup);
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initPixelTrail);
    } else {
      initPixelTrail();
    }
  })();
</script>

